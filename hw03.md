---
**作业 Part 1 of 2**
--- 

#Write out variables x, y and z in binary code#

1) int8 _t x = 67;&#8195;int8 _t y = -7;&#8195; int8 _t z = y - x;

&#8195;**x=01000011**&#8195;**y=11111001**&#8195;**z=10110110**  

2) int8_t x = 0xd3;

因为0xd3=13*16+3=211>127,超出了8位int所能表示的最大正整数，所以会产生溢出。(实际会输出-45)

&#8195;**x=11010011**

3) uint8_t x = 0xd3;

&#8195;**x=11010011**

4) int8 _t x = 127; int8 _t y = -7; int8 _t z = y – x;

因为z=y-x=-134<-128,超出了8位int所能表示的最小负整数，所以会产生溢出。（实际会输出122）

&#8195;**x=01111111**&#8195;**y=11111001**&#8195;**z=01111010**

5) float x = 1.125;

&#8195;1.125用二进制表示为1.001.

&#8195;**x=0 01111111 00100000000000000000000**

6) float x = 23.0;

&#8195;23.0用二进制表示为 10111

&#8195;**x=0 10000011 01110000000000000000000**

7) float x = 0.45;

&#0.45无法化成有限的二进制小数

&#8195;**x=0 01111101 11001100110011001100110**



由上可知，2)中的x和4)中的z发生了溢出错误，7) 中的x因为自身无法化为有限小数而产生了精度误差。

---
**作业 Part 2 of 2**
---
# 解释概念 #
1**)Method of complements**:In mathematics and computing, the method of complements is a technique used to subtract one number from another using only addition of positive numbers.

计算机科学中，补数的最大应用点为，在处理加法和减法中，不会因为数字的正负使用不同的计算方式。只要一种加法电路就可以处理各种有符号数加法，而且减法可以用一个数加上另一个数的补数来表示，因此只要有加法电路及补数电路即可完成各种有符号数的加法及减法，电路设计上相当方便。

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538734730628&di=dd7fb2ff136360dca4f2dba1d42a8859&imgtype=0&src=http%3A%2F%2Fpic.baike.soso.com%2Fp%2F20130617%2Fbki-20130617131959-12368197.jpg)

![](https://pic.baike.soso.com/p/20140624/20140624222129-513877422.jpg)

2)**Byte**:The byte is a unit of digital information that most commonly consists of eight bits, representing a binary number. 

![](https://cdn.ttgtmedia.com/rms/onlineImages/storage-memory_capacity_chart_mobile.png)

"Byte" is also a song by Dutch DJs Martin Garrix and Brooks.It was released on 7 April 2017, via Garrix's record label STMPD RCRDS and Sony.

![](https://upload.wikimedia.org/wikipedia/en/5/52/Byte_Martin_Garrix_Brooks.jpg)

3)**Integer (computer science)**:In computer science, an integer is a datum of integral data type, a data type that represents some range of mathematical integers. 

 Integral data types may be of different sizes and may or may not be allowed to contain negative values.

![](https://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=82dd6e31e3dde711e7874bf097dfe223/bf096b63f6246b605b8c6c40edf81a4c510fa200.jpg)

4)**Floating point**:In computing, floating-point arithmetic (FP) is arithmetic using formulaic representation of real numbers as an approximation so as to support a trade-off between range and precision.

浮点计算是指浮点数参与浮点计算的运算，这种运算通常伴随着因为无法精确表示而进行的近似或舍入。
一个浮点数a由两个数m和e来表示：a = m × b^e(b的e次方）。在任意一个这样的系统中，我们选择一个基数b（记数系统的基）和精度p（即使用多少位来存储）。m（即尾数）是形如±d.ddd...ddd的p位数（每一位是一个介于0到b-1之间的整数，包括0和b-1）。如果m的第一位是非0整数，m称作规格化的。有一些描述使用一个单独的符号位（s 代表+或者-）来表示正负，这样m必须是正的。e是指数。
这种设计可以在某个固定长度的存储空间内表示定点数无法表示的更大范围的数。

大部分计算机采用二进制（b=2）的表示方法。位(bit）是衡量浮点数所需存储空间的单位，通常为32位或64位，分别被叫作单精度和双精度。有一些计算机提供更大的浮点数，例如英特尔公司的浮点运算单元Intel8087协处理器（以及其被集成进x86处理器中的后代产品）提供80位长的浮点数，用于存储浮点运算的中间结果。还有一些系统提供128位的浮点数。

![](http://www.ad.siemens.com.cn/club/bbs/upload/634675793073073750.jpg)

## 证明 ##
1)

由公式可知，N[I]=2<sup>k</sup>-I.

又N[I]=2<SUP>k</sup>-I=[(2<sup>k</sup>-1)-I]+1=[(2-1)×2<sup>k-1</sup>+(2-1)×2<sup>k-2</sup>+...+(2-1)×2+(2-1)×1-(b<sub>k</sub>×2<sup>k-1</sup>+b<sub>k-1</sub>×2<sup>k-2</sup>+...b<sub>2</sub>×k+b<sub>1</sub>)]+1

整理可得：

N[I]=[(1-b<sub>k</sub>)×2<sup>k-1</sup>+(1-b<sub>k-1</sub>)×2<sup>k-2</sup>+...+(1-b<sub>2</sub>)×2+(1-b<sub>1</sub>)]+1

又在二进制中，b<sub>i</sub>=0或b<sub>i</sub>=1.&#8195;当b<sub>i</sub>=0时,1-b<sub>i</sub>=1；当b<sub>i</sub>=1时,1-b<sub>i</sub>=0。

综上可得，二进制的负数（two‘s complement of X）等于 X 的 ones’
complement ＋ 1（X每位求反加1）。


2)

**Int8_t x = - 017; 请用8进制描述变量 x。**

x=(-15)<sub>10</sub>=(11110001)<sub>2</sub>=(361)<sub>8</sub>

x用8进制表示为(361)<sub>8</sub>。

##证明 ##
**1)C程序：int8_t x = -0x1f;&#8195; int y = x; &#8195;请用16进制描述变量 x 和 y，并说明 int y = x 的计算过程。**

x=(-31)<sub>10</sub>=(11100001)<sub>2</sub>=(E1)<sub>16</sub>

y=(11111111111111111111111111100001)<sub>2</sub>=(FFFFFFE1)<sub>16</sub>

将一个字节的x赋值给四个字节的y，因为x是负值，而扩展一个负数的时候需要在保留原值的基础上将扩展的高位全赋为1，因而y变为（11111111111111111111111111100001)<sub>2</sub>。

**2)请用数学证明，为什么可以这么计算。**

由之前的证明即


N[I]=2<sup>k</sup>-I.

又N[I]=2<SUP>k</sup>-I=[(2<sup>k</sup>-1)-I]+1=[(2-1)×2<sup>k-1</sup>+(2-1)×2<sup>k-2</sup>+...+(2-1)×2+(2-1)×1-(b<sub>k</sub>×2<sup>k-1</sup>+b<sub>k-1</sub>×2<sup>k-2</sup>+...b<sub>2</sub>×k+b<sub>1</sub>)]+1

整理可得：

N[I]=[(1-b<sub>k</sub>)×2<sup>k-1</sup>+(1-b<sub>k-1</sub>)×2<sup>k-2</sup>+...+(1-b<sub>2</sub>)×2+(1-b<sub>1</sub>)]+1

又在二进制中，b<sub>i</sub>=0或b<sub>i</sub>=1.&#8195;当b<sub>i</sub>=0时,1-b<sub>i</sub>=1；当b<sub>i</sub>=1时,1-b<sub>i</sub>=0。

可知，二进制的负数等于该数各位取反再加一。

假设y从第x+1位到第n位为扩展的高位，从第1位到第x位是原值。

y=b<sub>n</sub>×2<sup>n-1</sup>+b<sub>n-1</sub>×2<sup>n-2</sup>+....+b<sub>x</sub>×2<sup>x-1</sup>+...+b<sub>2</sub>×2+b<sub>1</sub>

又从第x+1位到第n位均为1，取反后均为0

所以y=b<sub>x</sub>×2<sup>x-1</sup>+...+b<sub>2</sub>×2+b<sub>1</sub>

而剩下的原值取反加1显然即为对应的正数，这一点也显然已有上式证得。

因此将负数的扩展为取1不会影响该数的大小。

## NaN 是什么？##
IEEE 754 specifies a special value called "Not a Number" (NaN) to be returned as the result of certain "invalid" operations, such as 0/0, ∞×0, or sqrt(−1).

在浮点数运算中，NaN与无穷大的概念不同，尽管两者均是以浮点数表示实数时的特殊值。无效操作（Invalid Operation）同样也不同于算术溢出（可能返回无穷大）和算术下溢出（可能返回最小的一般数值、特殊数值、零等）。

IEEE 754-1985中，用指数部分全为1、小数部分非零表示NaN。以32位IEEE单精度浮点数的NaN为例，按位表示即：S111 1111 1AXX XXXX XXXX XXXX XXXX XXXX，S为符号位，符号位S的取值无关紧要；A是小数部分的最高位（ the most significant bit of the significand），其取值表示了NaN的类型：X不能全为0，并被称为NaN的payload。

返回NaN的运算有如下三种：

1. 至少有一个参数是NaN的运算
2.   下列除法运算：0/0、∞/∞、∞/−∞、−∞/∞、−∞/−∞

     下列乘法运算：0×∞、0×−∞

     下列加法运算：∞ + (−∞)、(−∞) + ∞

     下列减法运算：∞ - ∞、(−∞) - (−∞)
3.  产生复数结果的实数运算，例如：
 
    对负数进行开偶次方的运算

    对负数进行对数运算

    对正弦或余弦到达域以外的数进行反正弦或反余弦运算

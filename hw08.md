---
**作业 Part 1 of 2**
---

#1、阅读 Pseudocode Standard。#

1）用伪代码描述将十进制转换成16进制的方法:

```
READ number

REPEAT
	
	divide the number by 16
	make the remainder the next digit to the left in the answer
		CASE remainder OF
				10			:replace remainder with A
				11			:replace remainder with B
				12			:replace remainder with C
				13			:replace remainder with D
				14			:replace remainder with E
				15			:replace remainder with F
		ENDCASE
UNTIL	 the quotient is zero

```

2）C语言实现:

我最开始想到的程序是这样的：

```C

    #include<stdio.h>

    int main() {

	int number;
	int quotient;
	int remainder;
	char result[100];
	int i=0;
	
	scanf("%d",&number);	//输入想要转为十六进制的十进制数
	
	do {

	quotient=number/16;		
	remainder=number%16;		//将十进制的数除以16，保留得到的余数，再用商继续除以16得余数，就是十六进制中的每一位上的数字
	number=quotient;

		if(remainder>=10) {
			result[i]=remainder-10+'A';		//如果余数大于等于10，将它变为'A'-'Z'
			i++;
		}

		else {
		
		result[i]=remainder+'0';		//如果余数小于10，将它转变为字符char类型
		i++;
		
		}


	} while(quotient);

	while(i>=0) {
		printf("%c",result[i-1]);			
		i--;					//将数组逆向输出
	}

	}
```

3）使用 -1, 0, 1, 15, 26，3265 做为输入测试你的程序：

但是在调试过程中，我们发现：

![](https://github.com/GUOJIAYII/swi-homework/blob/gh-pages/images/wrong.png?raw=true)

这个程序只有对非负的整数才能进行正确的转换，如果输入的数字为-1，无法得到正确的结果。


这个问题的原因就在于忘记考虑负数，而-1不能通过result[i]=remainder+'0'这种方法变成char类型。	我们不妨通过取绝对值的方法，让负数和正数的处理方式相同，只是在最后判断一下是否需要输出一个负号即可。

最后的程序如图：

```C

	#include<stdio.h>
	#include<math.h>

	int main() {
	int number;
	int quotient;
	int remainder;
	int sign;
	char result[100];
	int i=0;
	
	scanf("%d",&number);
	sign=number;
	
	do {
		quotient=abs(number/16);
		remainder=abs(number%16);
		
		
		
		if(remainder>=10) {
			result[i]=remainder-10+'A';
			i++;
		}
		
		else if(remainder>0&&remainder<10){
			result[i]=remainder+'0';
			i++;
		}
		
		
		
		number=quotient;
		
	} while(quotient);
	
	if(sign<0)
		printf("-");
	while(i>=0) {
		
		printf("%c",result[i-1]);
		i--;
	} 
	
	return 0;
	} 
	
```

再次对程序进行测试：

![](https://github.com/GUOJIAYII/swi-homework/blob/gh-pages/images/correct.png?raw=true)

这次的结果都对了哦！

#2、名词解释与对比#

1）Top-down design ：

A top-down approach (also known as stepwise design and in some cases used as a synonym of decomposition) is essentially the **breaking down of a system** to gain insight into its compositional sub-systems in a reverse engineering fashion. In a top-down approach an overview of the system is formulated, specifying, but not detailing, any first-level subsystems. Each subsystem is then refined in yet greater detail, sometimes in many additional subsystem levels, until the entire specification is reduced to **base elements**. A top-down model is often specified with the assistance of "black boxes", which makes it easier to manipulate. However, black boxes may fail to clarify elementary mechanisms or be detailed enough to realistically validate the model. Top down approach starts with the big picture. It breaks down from there into smaller segments.

以一个手机为例，top-down design如图：

![](https://github.com/GUOJIAYII/swi-homework/blob/gh-pages/images/topdowndesign.jpg?raw=true)

2） Work breakdown structure (WBS)：

A work-breakdown structure (WBS) in project management and systems engineering, is a **deliverable-oriented breakdown** of a project into smaller components. A work breakdown structure is a key project deliverable that organizes the team's work into manageable sections. The Project Management Body of Knowledge defines the work-breakdown structure "A **hierarchical decomposition** of the total scope of work to be carried out by the project team to accomplish the project objectives and create the required deliverables."


3）简述管理学 WBS 与 信息学Top-down设计的异同：

在我看来，WBS与Top-down design在本质上是相同的，即都是为了解决复杂的问题而将问题一步步分解，知道达成最基本的单元，之后的完成就会比较容易了。并且这两种方法在设计的同时都只是将一个系统层层递进分为一个个子系统，但并不关注到底如何这些系统的具体实现。

不同点也就是面对的对象不同，WBS通过将工作进行分解而将一个很大的项目分解为许多可交付的组成部分，从而可以交由不同的人来完成，实现团队的工作组织。 而Top-down采取从上到下的分解方法，使得解决更复杂的编程问题会更容易。


**用伪代码表示洗衣机控制程序**


1）请使用伪代码分解“正常洗衣”程序的大步骤。包括注水、浸泡等：

```

	pour water
	soak clothes
	wash clothes
	rinse clothes
	dehydrate clothes
	discharge water

```

2）进一步用基本操作、控制语句（IF、FOR、WHILE等）、变量与表达式,写出每个步骤的伪代码:

```

	SET standard_water_volume=n
	SET soak_time=time1
	SET standard_wash_time=time2

	WHILE get_water_volume() <n
		water_in_switch(open)
	ENDWHILE
	water_in_switch(close)		//注水到指定高度

	WHILE time_counter()<time1
		wait
	ENDWHILE				//在指定的时间浸泡衣物
	
	time_counter()=0		//将时间计数清零
	
	WHILE time_counter()<time2
		motor_run(left)
	ENDWHIE				
	
	time_counter()=0	
	
	WHILE time_counter()<time2
		motor_run(right)
	ENDWHILE
	
	time_counter()=0		//按照指定的时间洗涤衣服

	WHILE get_water_volume()>0
		water_out_switch(open)
	ENDWHILE
	water_out_switch(close)			//将洗衣机中的水排出

	WHILE time_counter()<time2
		motor_run(left)
	ENDWHIE				
	
	time_counter()=0	
	
	WHILE time_counter()<time2
		motor_run(right)
	ENDWHILE
	
	time_counter()=0		//按照指定的时间清洗衣服

	WHILE get_water_volume()>0
		water_out_switch(open)
	ENDWHILE
	water_out_switch(close)			//将洗衣机中的水排出

	WHILE time_counter()<time2
		motor_run(left)
	ENDWHIE				
	
	time_counter()=0	
	
	WHILE time_counter()<time2
		motor_run(right)
	ENDWHILE
	
	time_counter()=0			//将衣服脱水甩干

	halt(returncode)		//洗衣完成


```

3）根据你的实践，请分析“正常洗衣”与“快速洗衣”在用户目标和程序上的异同。你认为是否存在改进（创新）空间，简单说明你的改进意见？

我认为“正常洗衣”大多用于家用，对洗衣的时间长度没有太高的要求，比较要求衣服的清洗干净的程度，因此这种模式的程序会将洗衣时间设置的长一点，并且可以多次进行清洗，而不只是简单的一次洗涤和漂洗。
	
与之相对，“快速洗衣”模式更适合独自使用，比如男生打球运动后需要清洗衣服，但又不能花太长的时间去等待；或者外出在宾馆中有衣物需要清洗，这就需要能够减少洗衣时间，尽快洗好。这种情况下并不过多要求衣服洗得特别干净，因此这种模式的程序会在能够洗干净衣服的前提下，将洗衣时间设置的尽可能短，并且洗衣次数也会尽可能的减少。

从上面伪代码的编写程序中，我们可以很明显的体会出来其实洗衣机的程序无非就是加水、转动清洗、排水、转动脱水几部组成，但是因为这几部分没有单独提炼出来，导致程序很复杂，不能让人一眼就看明白。所以不妨将这几部分作为子程序，以简化这个程序。同时，可以适当的对这些模块添加一些参数，使之更简单易读。

4）通过步骤3），提取一些共性功能模块（函数），简化“正常洗衣”程序，使程序
变得更利于人类理解和修改维护。


我们可以将这些功能模块分为：

1.注水到指定高度&#8195;2.浸泡时等待一段时间&#8195;3.洗衣机向某个方向进行转动一段时间&#8195;4.排水
	
理清这些共有的功能模块后，我们发现伪代码流程会大大简化！

比如，注水到指定高度，只要设置好一个参数，那么这个函数块不仅在“正常洗衣”的模式中可以应用，在其他模式中也可以使用这个功能块！同时，只要通过设置好的参数告诉洗衣机向哪个方向转动、转动多长时间，那么洗涤、漂洗和脱水的流程都只需要调用这个函数即可！

先写好这些功能模块：


```

pour_water (standard _ water _ volume)

	WHILE get_water_volume() <standard _water _ volume
		water_in_switch(open)
	ENDWHILE
	water_in_switch(close)		//注水到指定高度
	
```

```

wait(time)

	WHILE time_counter()<time
		
	ENDWHILE		

```

```

motor_run(direction,time)
		
	WHILE time_counter()<time
		motor_run(direction)
	ENDWHILE

```

```

discharge_water()

	WHILE get_water_volume() > 0
		water_out_switch(open)
	ENDWHILE
	water_out_switch(close)

```

然后，在这个基础上，我们之前的伪代码可以化简成如下：

```
pour_water(standard _water _ volume)

wait(time1)				//浸泡

motor_run(left,time2)

motor_run(right,time2)		//洗涤

discharge_water()

pour_water(standard _water _ volume)

motor_run(left,time2)

motor_run(right,time2)			//清洗

discharge_water()

motor_run(left,time2)

motor_run(right,time2)			//脱水

```

预习Object-Oriented Design：

在经典的 Beginner's guide to Construct 2 中，每一个怪物都是一个object，玩家同样也是一个object。但是所有的怪物又组成了一个class，因为他们的data和action是类似的，具有相同的性质。

field包含一个class的properties和behaviors。比如monster中含有每个怪物的和name、position等properties和他们的behaviors， 比如bound to layout,8 direction等。

method是一个处理object中数据的一个subprogram，比如玩家与怪物相撞后生命值减一。



